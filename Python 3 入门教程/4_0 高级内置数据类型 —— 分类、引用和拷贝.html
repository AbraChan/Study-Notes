<html>
<head>
  <title>4_0 高级内置数据类型 —— 分类、引用和拷贝</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/607057 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1652"/>
<h1>4_0 高级内置数据类型 —— 分类、引用和拷贝</h1>

<div>
<span><div><div><div><div><div><span style="font-size: 12pt;">【本文结构】</span></div><ol><li><div><span style="font-size: 12pt;">Python 内置数据类型</span></div></li><li><div><span style="font-size: 12pt;">Python 变量的引用</span></div></li><li><div><span style="font-size: 12pt;">Python 传值和传引用的区别</span></div></li><li><div><span style="font-size: 16px;">Python 浅拷贝和深拷贝</span></div></li></ol><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">【1</span> <a href="https://docs.python.org/zh-cn/3.7/library/stdtypes.html" style="font-size: 12pt;">Python 内置数据类型</a><span style="font-size: 12pt;">】</span></div><ul><li><div><span style="font-size: 12pt;">Python 内置类型：</span></div></li><ol><li><div><span style="font-size: 10pt; color: rgb(70, 70, 70);">迭代器类型 </span><span style="font-size: 10pt; color: rgb(70, 70, 70);">iterator</span></div></li><li><div><span style="font-size: 10pt; color: rgb(70, 70, 70);">生成器类型 </span><span style="font-size: 10pt; color: rgb(70, 70, 70);">generator</span></div></li><li><div><span style="font-size: 10pt; color: rgb(70, 70, 70);">数字类型 </span><span style="font-size: 10pt; color: rgb(70, 70, 70);">number </span> <span style="font-size: 10pt; color: rgb(70, 70, 70);">-- 整数int、小数float、复数complex</span></div></li><li><div><span style="color: rgb(70, 70, 70);">序列类型</span> <span style="color: rgb(70, 70, 70);">sequence </span><span style="color: rgb(70, 70, 70);">-- 列表list、元组tuple、range</span></div></li><li><div><span style="color: rgb(70, 70, 70);">文本序列类型</span> <span style="color: rgb(70, 70, 70);">str</span><span style="color: rgb(70, 70, 70);">（字符串类型）</span></div></li><li><div><span style="color: rgb(70, 70, 70);">二进制序列类型 -- bytes, bytearray, memoryview</span></div></li><li><div><span style="font-size: 10pt; color: rgb(70, 70, 70);">映射类型</span> <span style="font-size: 10pt; color: rgb(70, 70, 70);">mapping </span><span style="font-size: 10pt; color: rgb(70, 70, 70);">-- 字典dict</span></div></li><li><div><span style="font-size: 10pt; color: rgb(70, 70, 70);">集合类型 -- 集合set、frozenset</span></div></li><li><div><span style="color: rgb(70, 70, 70);">上下文管理器类型</span></div></li><li><div><span style="color: rgb(70, 70, 70);">其它内置类型</span></div></li></ol><li><div><span style="font-size: 12pt;">Python中的数据类型也可以分为：</span></div></li><ul><li><div><span style="font-size: 11pt; color: rgb(70, 70, 70);">有序：可以使用下标（索引）访问元素，可以使用切片形式[start:stop:step]访问元素。</span></div></li><li><div><span style="font-size: 11pt; color: rgb(70, 70, 70);">无序：</span></div></li><li><div><span style="font-size: 11pt; color: rgb(70, 70, 70);">可变：可以被修改。</span></div></li><li><div><span style="font-size: 11pt; color: rgb(70, 70, 70);">不可变：</span></div></li></ul></ul><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 130px;"></col><col style="width: 130px;"></col><col style="width: 130px;"></col></colgroup><tbody><tr><td style="background-color: rgb(0, 129, 194); border: 1px solid rgb(0, 103, 155); width: 130px; padding: 8px;"><div><br/></div></td><td style="background-color: rgb(0, 129, 194); border: 1px solid rgb(0, 103, 155); width: 130px; padding: 8px;"><div><span style="font-size: 16px; color: rgb(255, 255, 255); font-weight: bold;">有序</span></div></td><td style="background-color: rgb(0, 129, 194); border: 1px solid rgb(0, 103, 155); width: 130px; padding: 8px;"><div><span style="font-size: 16px; color: rgb(255, 255, 255); font-weight: bold;">无序</span></div></td></tr><tr><td style="background-color: rgb(0, 129, 194); border: 1px solid rgb(0, 103, 155); width: 130px; padding: 8px;"><div><span style="font-size: 16px; color: rgb(255, 255, 255); font-weight: bold;">可变</span></div></td><td style="width: 130px; padding: 8px; border: 1px solid;"><div><span style="font-size: 16px;">列表</span></div></td><td style="width: 130px; padding: 8px; border: 1px solid;"><div><span style="font-size: 16px;">字典、集合</span></div></td></tr><tr><td style="background-color: rgb(0, 129, 194); border: 1px solid rgb(0, 103, 155); width: 130px; padding: 8px;"><div><span style="font-size: 16px; color: rgb(255, 255, 255); font-weight: bold;">不可变</span></div></td><td style="width: 130px; padding: 8px; border: 1px solid;"><div><span style="font-size: 16px;">字符串、元组</span></div></td><td style="width: 130px; padding: 8px; border: 1px solid;"><div><span style="font-size: 16px;">数值</span></div></td></tr></tbody></table><div><br/></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">【2</span> <span style="font-size: 12pt;"><a href="https://blog.csdn.net/shen_chengfeng/article/details/80687396" style="font-size: 12pt;">Python 变量的引用</a></span><span style="font-size: 12pt;">】</span></div><ul><li><div><span style="font-size: 12pt;">在Python中定义一个变量便会在内存中开辟一块空间来存储这个变量的值，访问这块内存需要用到变量名，也就是说</span><span style="font-size: 12pt; color: rgb(173, 0, 0);">变量名实际存储的是变量在内存中的地址</span><span style="font-size: 12pt;">。</span></div></li><ul><li><div><span style="font-size: 12pt;">但是我们用使用print（）函数打印变量得到的却是这块内存上存储的实际数值。</span></div></li><li><div><span style="font-size: 12pt;">要获得变量在内存中的地址，可以使用id（）函数。</span></div></li></ul></ul><div><span style="font-size: 12pt;"><br/></span></div><ul><li><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">基本数据类型的引用</span>（数值型、字符串）</span></div></li><ul><li><div><span style="font-size: 14.6667px;"><span style="font-size: 14.6667px; color: rgb(173, 0, 0); font-weight: bold;">常规使用</span></span></div></li><ul><li><div><span style="font-size: 11pt;">变量之间的赋值其实是把一个变量的内存地址传递给另一个变量，这样两个变量便都</span><span style="font-size: 11pt; color: rgb(173, 0, 0);">指向内存中的</span><span style="font-size: 11pt; color: rgb(173, 0, 0); font-weight: bold;">同一块</span><span style="font-size: 11pt; color: rgb(173, 0, 0);">空间</span><span style="font-size: 11pt;">，因此这两个变量的值和地址是相等的。</span><span style="background-color: rgb(255, 250, 165);font-size: 11pt;-evernote-highlight:true;">(见 part 1）</span></div></li><li><div><span style="font-size: 11pt;">此时如果有第三个变量c的值与a的相等，那么c的地址与a的地址也一样。</span><span style="font-size: 11pt; color: rgb(173, 0, 0);">这一点请大家牢记</span><span style="font-size: 11pt;">。</span><span style="font-size: 11pt;background-color: rgb(255, 250, 165);-evernote-highlight:true;">(见 part 2）</span></div></li><li><div><span style="font-size: 11pt;">此时如果修改变量c的值，那么会在内存中新开辟一块内存来存储新的变量值，这块新的内存地址将会赋值给变量名c。</span><span style="font-size: 11pt;background-color: rgb(255, 250, 165);-evernote-highlight:true;">(见 part 3）</span></div></li></ul><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(173, 0, 0); font-weight: bold;">基本数据类型作为函数参数</span></span></div></li><ul><li><div><span style="font-size: 11pt;">基</span><span style="font-size: 11pt;">本数据类型作为函数实参同样是这个道理。</span><span style="font-size: 11pt;background-color: rgb(255, 250, 165);-evernote-highlight:true;">(见 part 4）</span></div></li></ul></ul></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 9pt;color: rgb(51, 51, 51);font-family: Monaco;background-color: rgb(255, 250, 165);-evernote-highlight:true;"># part 1</span></div><div>&gt;&gt;&gt; a = 1</div><div>&gt;&gt;&gt; b = a</div><div>&gt;&gt;&gt; print(&quot;a=%d  id(a)=%d&quot; % (a, id(a)))    # a=1  id(a)=140722690577440</div><div>&gt;&gt;&gt; print(&quot;b=%d  id(b)=%d&quot; % (b, id(b)))    # b=1  id(b)=140722690577440</div><div><br/></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;"># part 2（上接 part 1）</span></div><div>&gt;&gt;&gt; c = 1</div><div>&gt;&gt;&gt; print(&quot;c=%d  id(c)=%d&quot; % (c, id(c)))    # c=1  id(c)=140722690577440</div><div><br/></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;"># part 3（上接 part 2）</span></div><div>&gt;&gt;&gt; c = 2</div><div>&gt;&gt;&gt; print(&quot;c=%d  id(c)=%d&quot; % (c, id(c)))    # c=2  id(c)=140722690577472</div><div>&gt;&gt;&gt; print(&quot;a=%d  id(a)=%d&quot; % (a, id(a)))    # a=1  id(a)=140722690577440</div><div>&gt;&gt;&gt; print(&quot;b=%d  id(b)=%d&quot; % (b, id(b)))    # b=1  id(b)=140722690577440</div><div><br/></div><div><br/></div><div><br/></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;"># part 4（上接 part 3）</span></div><div>&gt;&gt;&gt; def func(x):</div><div>...     print(&quot;x=%d  id(x)=%d&quot; % (x, id(x)))</div><div>...     x = 2</div><div>...     print(&quot;x=%d  id(x)=%d&quot; % (x, id(x)))</div><div>...</div><div><br/></div><div>&gt;&gt;&gt; print(&quot;a=%d  id(a)=%d&quot; % (a, id(a)))    # a=1  id(a)=140722690577440</div><div>&gt;&gt;&gt; func(a)</div><div>x=1  id(x)=140722690577440                  # x=1  id(x)=140722690577440</div><div>x=2  id(x)=140722690577472                  # x=2  id(x)=140722690577472</div><div><br/></div><div><br/></div><div><br/></div><div># </div><div>&gt;&gt;&gt; id(1)      # 140722690577440</div><div>&gt;&gt;&gt;</div><div>&gt;&gt;&gt; a = 1</div><div>&gt;&gt;&gt; id(a)      # 140722690577440</div><div>&gt;&gt;&gt;</div><div>&gt;&gt;&gt; a += 1</div><div>&gt;&gt;&gt; a</div><div>2</div><div>&gt;&gt;&gt; id(a)      # 140722690577472</div><div>&gt;&gt;&gt;</div><div>&gt;&gt;&gt; a += 1</div><div>&gt;&gt;&gt; a</div><div>3</div><div>&gt;&gt;&gt; id(a)      # 140722690577504</div></div><div><font style="font-size: 14pt;"><br/></font></div><ul><li><div><span style="font-size: 16px;"><span style="font-size: 16px; font-weight: bold;">高级数据类型的引用</span>（列表、字典等）</span></div></li><ul><li><div><span style="font-size: 12pt;">列表、字典等高级数据类型的变量名同样存储的变量的实际地址，一个列表名赋值给另一个变量，那么这两个变量便</span><span style="font-size: 12pt; color: rgb(173, 0, 0);">指向内存中的</span><span style="font-size: 12pt; color: rgb(173, 0, 0); font-weight: bold;">同一块</span><span style="font-size: 12pt; color: rgb(173, 0, 0);">地址</span><span style="font-size: 12pt;">。</span><span style="font-size: 11pt;background-color: rgb(255, 250, 165);-evernote-highlight:true;">(见 part a）</span></div></li><ul><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(168, 168, 168);">注意：高级数据类型在每次加载进内存的时候内存地址与上一次可能会不同。</span></span></div></li></ul><li><div><span style="font-size: 12pt; color: rgb(173, 0, 0);">此时如果修改list2，也会影响list1的值，但是两个变量在内存中的地址还是不变的</span><span style="font-size: 12pt;">。这一点是与基本数据类型不一样的。</span> <span style="font-size: 14.6667px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 250, 165); color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;-evernote-highlight:true;">(见 part b）</span></div></li><li><div><span style="font-size: 11pt;">此时如果有第三个列表list3的值也是[1,2,3,4]，可以推测list3的地址与list1的地址应该是一样的，</span><span style="font-size: 11pt; color: rgb(173, 0, 0);">但是事实并非如此</span><span style="font-size: 11pt;">。</span><span style="font-size: 11pt; color: rgb(173, 0, 0);">如果有第三个列表list3的值也是[1,2,3,4]，相当于在内存中新开辟一块内存来存储这个值</span><span style="font-size: 11pt;">。</span><span style="font-size: 14.6667px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 250, 165); color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;-evernote-highlight:true;">(见 part c）</span></div></li></ul></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;"># part a</span></div><div>&gt;&gt;&gt; list1 = [1,2,3]</div><div>&gt;&gt;&gt; list2 = list1</div><div><strike>&gt;&gt;&gt; print(&quot;list1 = <font color="#AD0000">%d</font>, id(list1) = %d&quot; % (<font color="#AD0000">list1</font>, id(list1)))</strike></div><div><strike>Traceback (most recent call last):</strike></div><div><strike>  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</strike></div><div><strike>TypeError: %d format: a number is required, not list</strike></div><div><br/></div><div>&gt;&gt;&gt; print(&quot;list1 = {},   id(list1) = {}&quot;.format(list1, id(list1)))    # list1 = [1, 2, 3],   id(list1) = 2020261388936</div><div>&gt;&gt;&gt; print(&quot;list2 = {},   id(list2) = {}&quot;.format(list2, id(list2)))    # list2 = [1, 2, 3],   id(list2) = 2020261388936</div><div><br/></div><div><br/></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;"># part b（上接 part a）</span></div><div>&gt;&gt;&gt; list2.append(4)</div><div>&gt;&gt;&gt; print(&quot;list2 = {},   id(list2) = {}&quot;.format(list2, id(list2)))    # list2 = [1, 2, 3, <span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">4</span>],   id(list2) = 2020261388936</div><div>&gt;&gt;&gt; print(&quot;list1 = {},   id(list1) = {}&quot;.format(list1, id(list1)))    # list1 = [1, 2, 3, <span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">4</span>],   id(list1) = 2020261388936</div><div><br/></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;"># part c（上接 part b）</span></div><div>&gt;&gt;&gt; list3 = [1, 2, 3, 4]</div><div>&gt;&gt;&gt; print(&quot;list3 = {},   id(list3) = {}&quot;.format(list3, id(list3)))    # list3 = [1, 2, 3, 4],   id(list3) = 2020261886216</div><div>&gt;&gt;&gt;</div><div>&gt;&gt;&gt; list4 = [1, 2, 3]</div><div>&gt;&gt;&gt; print(&quot;list4 = {},   id(list4) = {}&quot;.format(list4, id(list4)))    # list4 = [1, 2, 3],   id(list4) = 2020264974152</div><div>&gt;&gt;&gt;</div><div>&gt;&gt;&gt; list5 = [1, 2, 3]</div><div>&gt;&gt;&gt; print(&quot;list5 = {},   id(list5) = {}&quot;.format(list5, id(list5)))    # list5 = [1, 2, 3],   id(list5) = 2020264966664</div><div><br/></div><div><br/></div><div># 通过下面的编程实验（同时以相同元素的列表作为对照组，下面没有体现出来），我得出下面的结论：</div><div># 对于空元组，无论定义多少变量为空元组，它们的内存地址都是一样的。因为对于空元组来说，它的元素是确定不变的。</div><div># 对于非空元组，因为它的元素可能是可变类型，也可能是不可变类型，所以我猜测内部是对非空元组统一视其元素为可变类型的处理，<font color="#AD0000">或者说，将非空元组视为可变类型数据</font>。</div><div># 所以：对于非空元组，即使它们的值完全相同，内存地址也都是不一样的。</div><div>&gt;&gt;&gt; a = ()</div><div>&gt;&gt;&gt; type(a)        # &lt;class 'tuple'&gt;</div><div>&gt;&gt;&gt; id(a)          # 2020260839496</div><div>&gt;&gt;&gt;</div><div>&gt;&gt;&gt; b = tuple()</div><div>&gt;&gt;&gt; type(b)        # &lt;class 'tuple'&gt;</div><div>&gt;&gt;&gt; id(b)          # 2020260839496</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><br/></span></div><div>&gt;&gt;&gt; c = 1,2,3</div><div>&gt;&gt;&gt; c</div><div>(1, 2, 3)</div><div>&gt;&gt;&gt; id(c)         # 2020264873200</div><div><br/></div><div>&gt;&gt;&gt; d = tuple([1,2,3])</div><div>&gt;&gt;&gt; d</div><div>(1, 2, 3)</div><div>&gt;&gt;&gt; id(d)         # 2020264704112</div><div><br/></div><div>&gt;&gt;&gt; e = 1,2,3</div><div>&gt;&gt;&gt; e</div><div>(1, 2, 3)</div><div>&gt;&gt;&gt; id(e)         # 2020264704400</div><div><br/></div><div>&gt;&gt;&gt; f = ()</div><div>&gt;&gt;&gt; id(f)         # 2020260839496</div><div><br/></div><div>&gt;&gt;&gt; id(())</div><div>2020260839496</div></div></div><ul><div><span style="font-size: 12pt;"><br/></span></div><li><div><span style="font-size: 12pt;">小结：基于<span style="font-size: 12pt; font-weight: bold;">可变数据类型与不可变数据类型</span></span></div></li></ul><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 130px;"></col><col style="width: 130px;"></col><col style="width: 130px;"></col></colgroup><tbody><tr><td style="background-color: rgb(0, 129, 194); border: 1px solid rgb(0, 103, 155); width: 130px; padding: 8px;"><div><br/></div></td><td style="background-color: rgb(0, 129, 194); border: 1px solid rgb(0, 103, 155); width: 130px; padding: 8px;"><div><span style="font-size: 16px; color: rgb(255, 255, 255); font-weight: bold;">有序</span></div></td><td style="background-color: rgb(0, 129, 194); border: 1px solid rgb(0, 103, 155); width: 130px; padding: 8px;"><div><span style="font-size: 16px; color: rgb(255, 255, 255); font-weight: bold;">无序</span></div></td></tr><tr><td style="background-color: rgb(0, 129, 194); border: 1px solid rgb(0, 103, 155); width: 130px; padding: 8px;"><div><span style="font-size: 16px; color: rgb(255, 255, 255); font-weight: bold;">可变</span></div></td><td style="width: 130px; padding: 8px; border: 1px solid;"><div><span style="font-size: 16px;">列表</span></div></td><td style="width: 130px; padding: 8px; border: 1px solid;"><div><span style="font-size: 16px;">字典、集合</span></div></td></tr><tr><td style="background-color: rgb(0, 129, 194); border: 1px solid rgb(0, 103, 155); width: 130px; padding: 8px;"><div><span style="font-size: 16px; color: rgb(255, 255, 255); font-weight: bold;">不可变</span></div></td><td style="width: 130px; padding: 8px; border: 1px solid;"><div><span style="font-size: 16px;">字符串、元组</span></div></td><td style="width: 130px; padding: 8px; border: 1px solid;"><div><span style="font-size: 16px;">数值</span></div></td></tr></tbody></table><ul><ul><li><div><span style="font-size: 12pt;">Python 中的</span><span style="font-size: 12pt; color: rgb(173, 0, 0); font-weight: bold;">不可变</span><span style="font-size: 12pt; color: rgb(173, 0, 0);">数据类型</span><span style="font-size: 12pt;">，不允许变量的值发生变化，</span><span style="font-size: 10pt;">（</span><span style="font-size: 10pt; color: rgb(173, 0, 0);">包括<span style="font-size: 10pt; color: rgb(173, 0, 0); font-weight: bold;">空元组</span></span><span style="font-size: 10pt;">）</span></div></li><ul><li><div><span style="font-size: 11pt;">变量之间的赋值其实是把一个变量的内存地址传递给另一个变量，这样两个变量便都</span><span style="font-size: 11pt; color: rgb(173, 0, 0);">指向内存中的</span><span style="font-size: 11pt; color: rgb(173, 0, 0); font-weight: bold;">同一块</span><span style="font-size: 11pt; color: rgb(173, 0, 0);">空间</span><span style="font-size: 11pt;">，因此这两个变量的值和地址是相等的。</span></div></li><li><div><span style="font-size: 11pt;">如果改变了变量的值，相当于是新建了一个对象；</span></div></li><li><div><span style="font-size: 11pt;">而对于相同的值的不同变量，在内存中则只有一个对象（对应了同一块内存空间），内部会有一个<span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">引用计数</span>来记录有多少个变量引用这个对象。</span></div></li><li><div><span style="font-size: 11pt;">不可变类型的数据传参时，函数内部不会改变原数据的值，所以与原数据绑定的变量的值都不变。</span><span style="font-size: 10pt;">（</span><a href="https://blog.csdn.net/weixin_38881822/article/details/89396969" style="font-size: 10pt;">参考0</a><span style="font-size: 10pt;">）</span></div></li></ul><li><div><span style="font-size: 12pt;">Python 中的</span><span style="font-size: 12pt; color: rgb(173, 0, 0); font-weight: bold;">可变</span><span style="font-size: 12pt; color: rgb(173, 0, 0);">数据类型</span><span style="font-size: 12pt;">，允许变量的值发生变化，</span><span style="font-size: 10pt;">（</span><span style="font-size: 10pt; color: rgb(173, 0, 0); font-weight: bold;">非空元组</span><span style="font-size: 10pt; color: rgb(173, 0, 0);">归在这一类处理，因为它的元素可能是像列表这样的可变类型</span><span style="font-size: 10pt;">）</span></div></li><ul><li><div><span style="font-size: 11pt;">变量之间的赋值其实是把一个变量的内存地址传递给另一个变量，这样两个变量便都</span><span style="font-size: 11pt; color: rgb(173, 0, 0);">指向内存中的</span><span style="font-size: 11pt; color: rgb(173, 0, 0); font-weight: bold;">同一块</span><span style="font-size: 11pt; color: rgb(173, 0, 0);">空间</span><span style="font-size: 11pt;">，因此这两个变量的值和地址是相等的。</span></div></li><li><div><span style="font-size: 11pt;">即如果对变量进行append、+=等这种操作后，只是改变了变量的值，而不会新建一个对象，变量引用的对象的地址也不会变化，</span></div></li><li><div><span style="font-size: 11pt;">而对于相同的值的不同变量，在内存中则会存在不同的对象，即每个对象都有自己的地址，相当于内存中对于同值的对象保存了多份，这里不存在引用计数，是实实在在的对象。</span></div></li><li><div><span style="font-size: 11pt;">可变类型的数据传参时，函数内部可以改变原数据的值，所以与原数据绑定的变量的值可以被改变。</span><span style="font-size: 10pt;">（</span><a href="https://blog.csdn.net/weixin_38881822/article/details/89396969" style="font-size: 10pt;">参考0</a><span style="font-size: 10pt;">）</span></div></li></ul></ul></ul><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><br/></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">【3</span> <span style="font-size: 12pt;"><a href="https://blog.csdn.net/weixin_38881822/article/details/89396969" style="font-size: 12pt;">Python 传值和传引用的区别</a></span><span style="font-size: 12pt;">】</span><span style="font-size: 10pt;">（</span><a href="https://blog.csdn.net/weixin_38881822/article/details/89396969" style="font-size: 10pt;">参考0</a><span style="font-size: 10pt;">）</span></div><ul><li><div><span style="font-size: 12pt;">在 C/C++ 中，传值和传引用是函数参数传递的两种方式。</span></div></li><ul><li><div><span style="font-size: 16px;">传值：也叫按值传递，是指函数得到参数的副本。</span><span style="font-size: 10pt;">（</span><a href="https://blog.csdn.net/andybegin/article/details/85097459" style="font-size: 10pt;">参考1</a><span style="font-size: 10pt;">）</span></div></li><li><div><span style="font-size: 16px;">传引用：也叫按引用传递，是指函数得到参数的指针。</span><span style="font-size: 10pt;">（</span><a href="https://blog.csdn.net/andybegin/article/details/85097459" style="font-size: 10pt;">参考1</a><span style="font-size: 10pt;">）</span></div></li></ul><li><div><span style="font-size: 12pt; color: rgb(173, 0, 0); font-weight: bold;">Python 中一切皆为对象</span><span style="font-size: 12pt;">，数字是对象，列表是对象，函数也是对象，任何东西都是对象。而</span><span style="font-size: 12pt; color: rgb(173, 0, 0); font-weight: bold;">变量是对象的一个引用</span><span style="font-size: 12pt;">（又称为</span><span style="font-size: 12pt; color: rgb(173, 0, 0);">名字</span><span style="font-size: 12pt;"> or</span> <span style="font-size: 12pt; color: rgb(173, 0, 0);">标签</span><span style="font-size: 12pt;">），</span><span style="font-size: 12pt; color: rgb(173, 0, 0); font-weight: bold;">对象的操作都是通过引用来完成的</span><span style="font-size: 12pt;">。</span></div></li><ul><li><div><span style="font-size: 12pt;">在 Python 中，「变量」更准确叫法是「名字」，</span><span style="font-size: 12pt; color: rgb(173, 0, 0);">赋值操作</span> <span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(173, 0, 0);">=</span> 就是把一个名字绑定到一个对象上。就像给对象添加一个标签。</span></div></li><li><div><span style="font-size: 12pt; color: rgb(173, 0, 0); font-weight: bold;">变量本身没有类型信息</span><span style="font-size: 12pt;">，</span><span style="font-size: 12pt; color: rgb(173, 0, 0);">类型信息存储在对象中</span><span style="font-size: 12pt;">，这和C/C++中的变量有非常大的出入（C中的变量是一段内存区域）。</span></div></li><li><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(173, 0, 0);">Python 函数中，参数的传递本质上是一种赋值操作</span>，而赋值操作是一种名字到对象的绑定过程。</span></div></li></ul><li><div><span style="font-size: 12pt; color: rgb(173, 0, 0);">在python中，</span><span style="font-size: 12pt; color: rgb(173, 0, 0); font-weight: bold;">类</span><span style="font-size: 12pt; color: rgb(173, 0, 0); font-weight: bold;">型属于对象，变量是没有类型的</span><span style="font-size: 12pt;">，这正是python的语言特性，也是吸引着很多pythoner的一点。所有的变量都可以理解 是内存中一个对象的“引用”，或者，也可以看似c中void*的感觉。所以，</span><span style="font-size: 12pt; color: rgb(173, 0, 0);">希望大家在看到一个python变量的时候，把变量和真正的内存对象分开</span><span style="font-size: 12pt;">。</span><span style="font-size: 10pt;">（</span><a href="https://blog.csdn.net/ztf312/article/details/48418253" style="font-size: 10pt;">参考2</a><span style="font-size: 10pt;">）</span></div></li><li><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">综上：Python 中，赋值操作（包括函数参数传递）其实相当于 C/C++ 的传引用。</span></font></div></li></ul><div><br/></div><ul><li><div><span style="font-size: 12pt;">在 CPython 中，对象的引用数量归零后，对象会被立即销毁。如果除了循环引用之外没有其它引用，两个对象都会被销毁。</span><span style="font-size: 10pt;">（</span><a href="https://blog.csdn.net/andybegin/article/details/85097459" style="font-size: 10pt;">参考1</a><span style="font-size: 10pt;">）</span></div></li></ul><div><font style="font-size: 12pt;"><br/></font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">【4</span> <span style="font-size: 16px;"><a href="http://c.biancheng.net/view/vip_6004.html" style="font-size: 16px;">Python 浅拷贝和深拷贝</a></span><span style="font-size: 12pt;">】</span></div><ul><li><div><span style="font-size: 16px;"><span style="font-size: 16px; font-weight: bold;">浅拷贝（shallow copy）</span></span></div></li><ul><li><div><span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 12pt; color: rgb(178, 34, 34); font-family: &quot;Helvetica Neue&quot;, 微软雅黑, &quot;Microsoft Yahei&quot;, Helvetica, Arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">指的是重新分配一块内存，创建一个新的对象，但里面的元素是原对象中各个子对象的引用。</span></span></div></li><li><div><span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><font style="font-size: 12pt;"><span style="font-size: 12pt; font-family: &quot;Helvetica Neue&quot;, 微软雅黑, &quot;Microsoft Yahei&quot;, Helvetica, Arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">常见的浅拷贝的方法，是使用数据类型本身的</span><span style="font-size: 12pt; color: rgb(173, 0, 0); font-family: &quot;Helvetica Neue&quot;, 微软雅黑, &quot;Microsoft Yahei&quot;, Helvetica, Arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">构造器</span><span style="font-size: 12pt; color: rgb(68, 68, 68); font-family: &quot;Helvetica Neue&quot;, 微软雅黑, &quot;Microsoft Yahei&quot;, Helvetica, Arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">。</span></font></span></div></li></ul></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 11pt;">list1 = [1, 2, 3]</font></div><div><font style="font-size: 11pt;">list2 = <font color="#AD0000">list(</font>list1<font color="#AD0000">)</font></font></div><div><font style="font-size: 11pt;"><br/></font></div><div><font style="font-size: 11pt;">set1= set([1, 2, 3])</font></div><div><font style="font-size: 11pt;">set2 = <font color="#AD0000">set(</font>set1<font color="#AD0000">)</font></font></div></div><ul><ul><li><div><span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><font style="font-size: 12pt;"><span style="font-size: 12pt; font-family: &quot;Helvetica Neue&quot;, 微软雅黑, &quot;Microsoft Yahei&quot;, Helvetica, Arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">对于可变的序列，还可以通过</span><span style="font-size: 12pt; color: rgb(173, 0, 0); font-family: &quot;Helvetica Neue&quot;, 微软雅黑, &quot;Microsoft Yahei&quot;, Helvetica, Arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">切片操作符“：”</span><span style="font-size: 12pt; font-family: &quot;Helvetica Neue&quot;, 微软雅黑, &quot;Microsoft Yahei&quot;, Helvetica, Arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">来完成浅拷贝。</span></font></span></div></li></ul></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 11pt;">list1 = [1, 2, 3]</font></div><div><font style="font-size: 11pt;">list2 = <font color="#AD0000">list1[:]</font></font></div></div><ul><ul><ul><li><div><span style="font-size: 14px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(68, 68, 68); font-family: &quot;Helvetica Neue&quot;, 微软雅黑, &quot;Microsoft Yahei&quot;, Helvetica, Arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">不过需要注意的是，</span><span style="font-size: 14px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 14px; color: rgb(173, 0, 0); font-family: &quot;Helvetica Neue&quot;, 微软雅黑, &quot;Microsoft Yahei&quot;, Helvetica, Arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">对于元组，使用 tuple() 或者切片操作符 ':' 不会创建一份浅拷贝，相反它会返回一个指向相同元组的引用</span></span><span style="font-size: 14px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(68, 68, 68); font-family: &quot;Helvetica Neue&quot;, 微软雅黑, &quot;Microsoft Yahei&quot;, Helvetica, Arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">：</span></div></li></ul></ul></ul><div><span style="font-size: 11pt; color: rgb(68, 68, 68); font-family: &quot;Helvetica Neue&quot;;">                            </span></div><ul><ul><li><div><span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 12pt; font-family: &quot;Helvetica Neue&quot;, 微软雅黑, &quot;Microsoft Yahei&quot;, Helvetica, Arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">Python 还提供了对应的函数</span> <span style="font-size: 12pt; color: rgb(173, 0, 0); font-family: &quot;Helvetica Neue&quot;, 微软雅黑, &quot;Microsoft Yahei&quot;, Helvetica, Arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">copy.copy() 函数</span><span style="font-size: 12pt; font-family: &quot;Helvetica Neue&quot;, 微软雅黑, &quot;Microsoft Yahei&quot;, Helvetica, Arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">，适用于任何数据类型。</span></span></div></li></ul></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 11pt;">import copy</font></div><div><font style="font-size: 11pt;">list1 = [1, 2, 3]</font></div><div><font style="font-size: 11pt;">list2 = <font color="#AD0000">copy.copy(</font>list1<font color="#AD0000">)</font></font></div></div><div><font style="font-size: 12pt;"><br/></font></div><ul><ul><li><div><span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 12pt; color: rgb(173, 0, 0); font-family: &quot;Helvetica Neue&quot;, 微软雅黑, &quot;Microsoft Yahei&quot;, Helvetica, Arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">对数据采用浅拷贝的方式时，如果原对象中的元素不可变，那倒无所谓；但如果元素可变，浅拷贝通常会出现一些问题</span></span><span style="font-size: 14px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(68, 68, 68); font-family: &quot;Helvetica Neue&quot;, 微软雅黑, &quot;Microsoft Yahei&quot;, Helvetica, Arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">。例如：</span></div></li></ul></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;"><font style="font-size: 9pt;"><font># </font>首</font>先初始化了 list1 列表，包含一个列表和一个元组；然后对 list1 执行浅拷贝，赋予 list2。因为浅拷贝里的元素是对原对象元素的引用，因此 list2 中的元素和 list1 指向同一个列表和元组对象。</span></div><div><font style="font-size: 11pt;">&gt;&gt;&gt; list1 = [[1, 2], (30, 40)]</font></div><div><font style="font-size: 11pt;">&gt;&gt;&gt; list2 = list(list1)</font> <font color="#AD0000" style="font-size: 9pt;"># 浅拷贝</font></div><div><font style="font-size: 11pt;">&gt;&gt;&gt;</font></div><div><font style="font-size: 11pt;">&gt;&gt;&gt; id(list1)         </font> <font style="font-size: 9pt;"># 2248489192136</font></div><div><font style="font-size: 11pt;">&gt;&gt;&gt; id(list2)         </font> <font style="font-size: 9pt;"># 2248491345736</font></div><div><font style="font-size: 11pt;"><br/></font></div><div><font style="font-size: 9pt;background-color: rgb(255, 250, 165);-evernote-highlight:true;"><font># </font>list1.append(100) 表示对 list1 的列表新增元素 100。此操作不会对 list2 产生任何影响，因为 list2 和 list1 作为整体是两个不同的对象，并不共享内存地址。操作后 list2 不变，list1 会发生改变。</font></div><div><font style="font-size: 11pt;">&gt;&gt;&gt; list1.append(100)</font></div><div><font style="font-size: 11pt;">&gt;&gt;&gt; list1             </font> <font style="font-size: 9pt;"># [[1, 2], (30, 40), 100]</font></div><div><font style="font-size: 11pt;">&gt;&gt;&gt; list2             </font> <font style="font-size: 9pt;"># [[1, 2], (30, 40)]</font></div><div><br/></div><div><font style="font-size: 9pt;background-color: rgb(255, 250, 165);-evernote-highlight:true;"><span style="color: rgb(51, 51, 51); font-family: Monaco;"><font># </font></span>list1[0].append(3) 表示对 list1 中的第一个列表新增元素 3。因为 list2 是 list1 的浅拷贝，list2 中的第一个元素和 list1 中的第一个元素，共同指向同一个列表，因此 list2 中的第一个列表也会相对应的新增元素 3。</font></div><div><font style="font-size: 11pt;">&gt;&gt;&gt; list1[0].append(3)</font></div><div><font style="font-size: 11pt;">&gt;&gt;&gt; list1             </font> <font style="font-size: 9pt;"># [[1, 2, 3], (30, 40), 100]</font></div><div><font style="font-size: 11pt;">&gt;&gt;&gt; list2             </font> <font style="font-size: 9pt;"># [[1, 2, 3], (30, 40)]</font></div><div><font style="font-size: 11pt;">&gt;&gt;&gt; id(list1)          </font><font style="font-size: 9pt;"># 2248489192136</font></div><div><font style="font-size: 11pt;">&gt;&gt;&gt; id(list2)          </font><font style="font-size: 9pt;"># 2248491345736</font></div><div><font style="font-size: 11pt;"><br/></font></div><div><font style="font-size: 9pt;background-color: rgb(255, 250, 165);-evernote-highlight:true;"><font># </font>list1[1] += (50, 60)，因为元组是不可变的，这里表示对 list1 中的第二个元组拼接，然后重新创建了一个新元组作为 list1 中的第二个元素，而 list2 中没有引用新元组，因此 list2 并不受影响。</font></div><div><font style="font-size: 11pt;">&gt;&gt;&gt; list1[1] += (50, 60)</font></div><div><font style="font-size: 11pt;">&gt;&gt;&gt; list1             </font> <font style="font-size: 9pt;"># [[1, 2, 3], (30, 40, 50, 60), 100]</font></div><div><font style="font-size: 11pt;">&gt;&gt;&gt; list2             </font> <font style="font-size: 9pt;"># [1, 2, 3], (30, 40)]</font></div><div><font style="font-size: 11pt;">&gt;&gt;&gt; id(list1)          </font><font style="font-size: 9pt;"># 2248489192136</font></div><div><font style="font-size: 11pt;">&gt;&gt;&gt; id(list2)          </font><font style="font-size: 9pt;"># 2248491345736</font></div></div><ul><ul><ul><li><div><span style="font-size: 14px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(68, 68, 68); font-family: &quot;Helvetica Neue&quot;, 微软雅黑, &quot;Microsoft Yahei&quot;, Helvetica, Arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">通过这个例子，你可以很清楚地看到使用浅拷贝可能带来的副作用。如果想避免这种副作用，完整地拷贝一个对象，就需要使用</span><span style="font-size: 14px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(50, 135, 18); font-family: &quot;Helvetica Neue&quot;, 微软雅黑, &quot;Microsoft Yahei&quot;, Helvetica, Arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">深拷贝</span><span style="font-size: 14px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(68, 68, 68); font-family: &quot;Helvetica Neue&quot;, 微软雅黑, &quot;Microsoft Yahei&quot;, Helvetica, Arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">。</span></div></li></ul></ul></ul><div><font style="font-size: 12pt;"><br/></font></div><ul><li><div><span style="font-size: 16px;"><span style="font-size: 16px; font-weight: bold;">深拷贝（deep copy）</span></span></div></li></ul></div><ul><ul><li><div><font style="font-size: 12pt;"><span style="font-size: 12pt; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(178, 34, 34); font-family: &quot;Helvetica Neue&quot;, 微软雅黑, &quot;Microsoft Yahei&quot;, Helvetica, Arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">指重新分配一块内存，创建一个新的对象，并且将原对象中的元素，以</span><span style="font-size: 12pt; color: rgb(178, 34, 34); font-family: &quot;Helvetica Neue&quot;, 微软雅黑, &quot;Microsoft Yahei&quot;, Helvetica, Arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; text-decoration: underline;">递归</span><span style="font-size: 12pt; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(178, 34, 34); font-family: &quot;Helvetica Neue&quot;, 微软雅黑, &quot;Microsoft Yahei&quot;, Helvetica, Arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">的方式，通过创建新的子对象拷贝到新对象中。</span><span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 12pt; color: rgb(68, 68, 68); font-family: &quot;Helvetica Neue&quot;, 微软雅黑, &quot;Microsoft Yahei&quot;, Helvetica, Arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">因</span><span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 12pt; font-family: &quot;Helvetica Neue&quot;, 微软雅黑, &quot;Microsoft Yahei&quot;, Helvetica, Arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">此，新对象和原对象没有任何关联。</span></font></div></li><li><div><span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 12pt; font-family: &quot;Helvetica Neue&quot;, 微软雅黑, &quot;Microsoft Yahei&quot;, Helvetica, Arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">Python 中以 copy.deepcopy() 来实现对象的深度拷贝。</span></span><span style="font-size: 14px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(68, 68, 68); font-family: &quot;Helvetica Neue&quot;, 微软雅黑, &quot;Microsoft Yahei&quot;, Helvetica, Arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">比如上述例子写成下面的形式，就是深度拷贝：</span></div></li></ul></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; import copy</div><div>&gt;&gt;&gt; list1 = [[1, 2], (30, 40)]</div><div>&gt;&gt;&gt; list2 = copy.deepcopy(list1)</div><div>&gt;&gt;&gt;</div><div>&gt;&gt;&gt; list1           # [[1, 2], (30, 40)]</div><div>&gt;&gt;&gt; list2           # [[1, 2], (30, 40)]</div><div>&gt;&gt;&gt; id(list1)       # 2248491345928</div><div>&gt;&gt;&gt; id(list2)       # 2248489192136</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><br/></span></div><div>&gt;&gt;&gt; list1.append(100)</div><div>&gt;&gt;&gt; list1           # [[1, 2], (30, 40), 100]</div><div>&gt;&gt;&gt; list2           # [[1, 2], (30, 40)]</div><div>&gt;&gt;&gt; id(list1)       # 2248491345928</div><div>&gt;&gt;&gt; id(list2)       # 2248489192136</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><br/></span></div><div><font color="#AD0000">&gt;&gt;&gt; list1[0].append(3)</font></div><div><font color="#AD0000">&gt;&gt;&gt; list1          # [[1, 2, 3], (30, 40), 100]</font></div><div><font color="#AD0000">&gt;&gt;&gt; list2          # [[1, 2], (30, 40)]</font></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><br/></span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><br/></span></div><div>&gt;&gt;&gt; list1[1] += (50, 60)</div><div>&gt;&gt;&gt; list1          # [[1, 2, 3], (30, 40, 50, 60), 100]</div><div>&gt;&gt;&gt; list2          # [[1, 2], (30, 40)]</div></div><ul><ul><ul><li><div><span style="font-size: 14px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(68, 68, 68); font-family: &quot;Helvetica Neue&quot;, 微软雅黑, &quot;Microsoft Yahei&quot;, Helvetica, Arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">可以看到，无论 list1 如何变化，list2 都不变。因为此时的 list1 和 list2 完全独立，没有任何联系。</span></div></li></ul></ul></ul><div><span style="font-size: 11pt;"><br/></span></div><ul><ul><ul><li><div><span style="font-size: 14px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 14px; color: rgb(173, 0, 0); font-family: &quot;Helvetica Neue&quot;, 微软雅黑, &quot;Microsoft Yahei&quot;, Helvetica, Arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">不过，深度拷贝也不是完美的，往往也会带来一系列问题。如果被拷贝对象中存在指向自身的引用，那么程序很容易陷入无限循环。</span></span> <span style="font-size: 14px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(68, 68, 68); font-family: &quot;Helvetica Neue&quot;, 微软雅黑, &quot;Microsoft Yahei&quot;, Helvetica, Arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">例如：</span></div></li></ul></ul></ul><div><span style="font-size: 12pt;">                          </span><span style="font-size: 12pt;"><img src="4_0 高级内置数据类型 —— 分类、引用和拷贝_files/Image.png" type="image/png" data-filename="Image.png" width="652"/></span></div><ul><ul><ul><li><div><span style="font-size: 14px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(68, 68, 68); font-family: &quot;Helvetica Neue&quot;, 微软雅黑, &quot;Microsoft Yahei&quot;, Helvetica, Arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">此例子中，列表 x 中有指向自身的引用，因此 x 是一个无限嵌套的列表。但是当深度拷贝 x 到 y 后，程序并没有出现栈溢出的现象。这是为什么呢？</span></div></li><li><div><span style="font-size: 14px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(68, 68, 68); font-family: &quot;Helvetica Neue&quot;, 微软雅黑, &quot;Microsoft Yahei&quot;, Helvetica, Arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">其实，这是因为</span><span style="font-size: 14px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 14px; color: rgb(173, 0, 0); font-family: &quot;Helvetica Neue&quot;, 微软雅黑, &quot;Microsoft Yahei&quot;, Helvetica, Arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">深度拷贝函数 deepcopy 中会维护一个字典，记录已经拷贝的对象与其 ID</span></span><span style="font-size: 14px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(68, 68, 68); font-family: &quot;Helvetica Neue&quot;, 微软雅黑, &quot;Microsoft Yahei&quot;, Helvetica, Arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">。拷贝过程中，如果字典里已经存储了将要拷贝的对象，则会从字典直接返回。通过查看 deepcopy 函数实现的源码就会明白：</span></div></li></ul></ul></ul><div><span style="font-size: 12pt;">                          </span><span style="font-size: 12pt;"><img src="4_0 高级内置数据类型 —— 分类、引用和拷贝_files/Image [1].png" type="image/png" data-filename="Image.png" width="651"/></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div></div><div><br/></div></span>
</div></body></html> 